# å‹¤æ€ ç®¡ç†ã‚¢ãƒ—ãƒª - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## ğŸ“‹ ç›®æ¬¡

1. [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¦‚è¦](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¦‚è¦)
2. [èªè¨¼ãƒ»èªå¯](#èªè¨¼èªå¯)
3. [ãƒ‡ãƒ¼ã‚¿ä¿è­·](#ãƒ‡ãƒ¼ã‚¿ä¿è­·)
4. [é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](#é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£)
5. [å…¥åŠ›æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³](#å…¥åŠ›æ¤œè¨¼ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³)
6. [ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡](#ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡)
7. [ç›£æŸ»ãƒ»ãƒ­ã‚°](#ç›£æŸ»ãƒ­ã‚°)
8. [è„†å¼±æ€§å¯¾ç­–](#è„†å¼±æ€§å¯¾ç­–)
9. [GDPRãƒ»ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼å¯¾å¿œ](#gdprãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼å¯¾å¿œ)
10. [ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ](#ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ)
11. [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»)
12. [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š)

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¦‚è¦

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ–¹é‡

å‹¤æ€ ç®¡ç†ã‚¢ãƒ—ãƒªã¯ã€å¾“æ¥­å“¡ã®å€‹äººæƒ…å ±ã¨å‹¤å‹™ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ã†ãŸã‚ã€ä»¥ä¸‹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸå‰‡ã«åŸºã¥ã„ã¦è¨­è¨ˆãƒ»é‹ç”¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

#### åŸºæœ¬åŸå‰‡

- **æœ€å°æ¨©é™ã®åŸå‰‡**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¯å¿…è¦æœ€å°é™ã®æ¨©é™ã®ã¿ã‚’ä»˜ä¸
- **å¤šå±¤é˜²å¾¡**: è¤‡æ•°ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å±¤ã«ã‚ˆã‚‹åŒ…æ‹¬çš„ãªä¿è­·
- **ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆ**: ã™ã¹ã¦ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æ¤œè¨¼ãƒ»èªè¨¼
- **ãƒ‡ãƒ¼ã‚¿æœ€å°åŒ–**: å¿…è¦æœ€å°é™ã®ãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚’åé›†ãƒ»ä¿å­˜
- **é€æ˜æ€§**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–ã¨ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ã®é€æ˜æ€§ç¢ºä¿

#### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›®æ¨™

```typescript
/**
 * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›®æ¨™å®šç¾©
 */
const SECURITY_OBJECTIVES = {
  // CIA Triad
  confidentiality: {
    description: "æ©Ÿå¯†æ€§ - èªå¯ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿ãŒãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½",
    measures: ["æš—å·åŒ–ã«ã‚ˆã‚‹ä¿è­·", "ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡", "èªè¨¼ãƒ»èªå¯ãƒ¡ã‚«ãƒ‹ã‚ºãƒ "],
  },

  integrity: {
    description: "å®Œå…¨æ€§ - ãƒ‡ãƒ¼ã‚¿ã®æ­£ç¢ºæ€§ã¨ä¸€è²«æ€§ã‚’ä¿è¨¼",
    measures: ["ãƒ‡ã‚¸ã‚¿ãƒ«ç½²å", "ãƒãƒƒã‚·ãƒ¥æ¤œè¨¼", "ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†", "ç›£æŸ»ãƒ­ã‚°"],
  },

  availability: {
    description: "å¯ç”¨æ€§ - å¿…è¦ãªæ™‚ã«ã‚·ã‚¹ãƒ†ãƒ ãŒåˆ©ç”¨å¯èƒ½",
    measures: ["å†—é•·åŒ–", "ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—", "DDoSå¯¾ç­–", "ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆ"],
  },

  // è¿½åŠ ç›®æ¨™
  accountability: {
    description: "èª¬æ˜è²¬ä»» - ã™ã¹ã¦ã®æ“ä½œãŒè¿½è·¡å¯èƒ½",
    measures: ["åŒ…æ‹¬çš„ãªç›£æŸ»ãƒ­ã‚°", "ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•è¿½è·¡", "å¤‰æ›´å±¥æ­´ç®¡ç†"],
  },

  privacy: {
    description: "ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ - å€‹äººæƒ…å ±ã®é©åˆ‡ãªä¿è­·",
    measures: [
      "ãƒ‡ãƒ¼ã‚¿åŒ¿ååŒ–",
      "åŒæ„ç®¡ç†",
      "ãƒ‡ãƒ¼ã‚¿å‰Šé™¤æ¨©",
      "ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒã‚¤ãƒ‡ã‚¶ã‚¤ãƒ³",
    ],
  },
} as const;
```

### è„…å¨ãƒ¢ãƒ‡ãƒ«

```typescript
/**
 * è„…å¨åˆ†æ
 */
interface ThreatModel {
  category: string;
  threats: Array<{
    name: string;
    description: string;
    likelihood: "Low" | "Medium" | "High";
    impact: "Low" | "Medium" | "High";
    risk: "Low" | "Medium" | "High" | "Critical";
    mitigations: string[];
  }>;
}

const THREAT_MODEL: ThreatModel[] = [
  {
    category: "èªè¨¼ãƒ»èªå¯",
    threats: [
      {
        name: "ä¸æ­£ãƒ­ã‚°ã‚¤ãƒ³",
        description: "èªè¨¼æƒ…å ±ã®æ¼æ´©ã‚„ç·å½“ãŸã‚Šæ”»æ’ƒã«ã‚ˆã‚‹ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹",
        likelihood: "Medium",
        impact: "High",
        risk: "High",
        mitigations: [
          "Google OAuth 2.0ã«ã‚ˆã‚‹å¼·å›ºãªèªè¨¼",
          "MFAï¼ˆå¤šè¦ç´ èªè¨¼ï¼‰ã®å®Ÿè£…",
          "ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆæ©Ÿèƒ½",
          "ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã®ç›£è¦–",
        ],
      },
      {
        name: "æ¨©é™æ˜‡æ ¼",
        description: "ä¸€èˆ¬ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç®¡ç†è€…æ¨©é™ã‚’ä¸æ­£å–å¾—",
        likelihood: "Low",
        impact: "High",
        risk: "Medium",
        mitigations: [
          "ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆRBACï¼‰",
          "æœ€å°æ¨©é™ã®åŸå‰‡",
          "æ¨©é™å¤‰æ›´ã®ç›£æŸ»ãƒ­ã‚°",
          "å®šæœŸçš„ãªæ¨©é™ãƒ¬ãƒ“ãƒ¥ãƒ¼",
        ],
      },
    ],
  },
  {
    category: "ãƒ‡ãƒ¼ã‚¿ä¿è­·",
    threats: [
      {
        name: "ãƒ‡ãƒ¼ã‚¿æ¼æ´©",
        description: "å€‹äººæƒ…å ±ã‚„å‹¤å‹™ãƒ‡ãƒ¼ã‚¿ã®å¤–éƒ¨æµå‡º",
        likelihood: "Medium",
        impact: "Critical",
        risk: "Critical",
        mitigations: [
          "ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–ï¼ˆä¿å­˜æ™‚ãƒ»è»¢é€æ™‚ï¼‰",
          "ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡",
          "ãƒ‡ãƒ¼ã‚¿åˆ†é¡ãƒ»ãƒ©ãƒ™ãƒªãƒ³ã‚°",
          "DLPï¼ˆãƒ‡ãƒ¼ã‚¿æå¤±é˜²æ­¢ï¼‰å¯¾ç­–",
        ],
      },
      {
        name: "ãƒ‡ãƒ¼ã‚¿æ”¹ã–ã‚“",
        description: "å‹¤å‹™è¨˜éŒ²ã®ä¸æ­£ãªå¤‰æ›´ã‚„å‰Šé™¤",
        likelihood: "Low",
        impact: "High",
        risk: "Medium",
        mitigations: [
          "ãƒ‡ã‚¸ã‚¿ãƒ«ç½²å",
          "å¤‰æ›´å±¥æ­´ã®è¨˜éŒ²",
          "ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¨ãƒªã‚¹ãƒˆã‚¢",
          "æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯",
        ],
      },
    ],
  },
  {
    category: "ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³",
    threats: [
      {
        name: "XSSæ”»æ’ƒ",
        description: "æ‚ªæ„ã®ã‚ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®å®Ÿè¡Œ",
        likelihood: "Medium",
        impact: "Medium",
        risk: "Medium",
        mitigations: [
          "å…¥åŠ›å€¤ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³",
          "CSPï¼ˆContent Security Policyï¼‰",
          "HTTPOnly Cookieã®ä½¿ç”¨",
          "å‡ºåŠ›ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—",
        ],
      },
      {
        name: "CSRFæ”»æ’ƒ",
        description: "ã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ã‚¸ã‚§ãƒª",
        likelihood: "Medium",
        impact: "Medium",
        risk: "Medium",
        mitigations: [
          "CSRFãƒˆãƒ¼ã‚¯ãƒ³ã®å®Ÿè£…",
          "SameSite Cookieã®ä½¿ç”¨",
          "Referrerãƒ˜ãƒƒãƒ€ãƒ¼ã®æ¤œè¨¼",
          "ã‚«ã‚¹ã‚¿ãƒ ãƒ˜ãƒƒãƒ€ãƒ¼ã®è¦æ±‚",
        ],
      },
    ],
  },
];
```

## èªè¨¼ãƒ»èªå¯

### Google OAuth 2.0 èªè¨¼

```typescript
/**
 * èªè¨¼ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
 */
const AUTH_SECURITY_CONFIG = {
  // OAuth 2.0è¨­å®š
  oauth: {
    // PKCEï¼ˆProof Key for Code Exchangeï¼‰ã‚’ä½¿ç”¨
    usePKCE: true,
    // çŠ¶æ…‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã‚ˆã‚‹CSRFå¯¾ç­–
    useStateParameter: true,
    // ãƒãƒ³ã‚¹ã«ã‚ˆã‚‹ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–
    useNonce: true,
    // ã‚»ã‚­ãƒ¥ã‚¢ãªãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆURI
    allowedRedirectUris: [
      "https://your-app-domain.com/auth/callback",
      "https://your-app-domain.netlify.app/auth/callback",
    ],
  },

  // ãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†
  tokens: {
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™
    accessTokenExpiry: 3600, // 1æ™‚é–“
    // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™
    refreshTokenExpiry: 2592000, // 30æ—¥
    // ãƒˆãƒ¼ã‚¯ãƒ³ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
    rotateRefreshTokens: true,
    // ã‚»ã‚­ãƒ¥ã‚¢ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
    secureStorage: true,
  },

  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†
  session: {
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
    timeout: 28800, // 8æ™‚é–“
    // ã‚¢ã‚¤ãƒ‰ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
    idleTimeout: 1800, // 30åˆ†
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºå®šæ”»æ’ƒå¯¾ç­–
    regenerateSessionId: true,
    // ã‚»ã‚­ãƒ¥ã‚¢Cookieè¨­å®š
    secureCookies: {
      httpOnly: true,
      secure: true,
      sameSite: "strict",
    },
  },
} as const;

/**
 * ã‚»ã‚­ãƒ¥ã‚¢ãªèªè¨¼å®Ÿè£…
 */
class SecureAuthManager {
  private codeVerifier: string | null = null;
  private state: string | null = null;
  private nonce: string | null = null;

  /**
   * PKCEå¯¾å¿œã®èªè¨¼URLç”Ÿæˆ
   * @returns èªè¨¼URL
   */
  async generateSecureAuthUrl(): Promise<string> {
    // PKCE code verifierã‚’ç”Ÿæˆ
    this.codeVerifier = this.generateCodeVerifier();
    const codeChallenge = await this.generateCodeChallenge(this.codeVerifier);

    // çŠ¶æ…‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç”Ÿæˆï¼ˆCSRFå¯¾ç­–ï¼‰
    this.state = this.generateSecureRandom(32);

    // ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆï¼ˆãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒå¯¾ç­–ï¼‰
    this.nonce = this.generateSecureRandom(32);

    const params = new URLSearchParams({
      client_id: process.env.GOOGLE_CLIENT_ID!,
      redirect_uri: AUTH_SECURITY_CONFIG.oauth.allowedRedirectUris[0],
      scope:
        "openid email profile https://www.googleapis.com/auth/spreadsheets",
      response_type: "code",
      state: this.state,
      nonce: this.nonce,
      code_challenge: codeChallenge,
      code_challenge_method: "S256",
      access_type: "offline",
      prompt: "consent",
    });

    // çŠ¶æ…‹ã‚’ã‚»ã‚­ãƒ¥ã‚¢ã«ä¿å­˜
    this.securelyStoreAuthState({
      state: this.state,
      nonce: this.nonce,
      codeVerifier: this.codeVerifier,
    });

    return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
  }

  /**
   * èªè¨¼ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®æ¤œè¨¼
   * @param code èªè¨¼ã‚³ãƒ¼ãƒ‰
   * @param state çŠ¶æ…‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
   * @returns ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±
   */
  async handleAuthCallback(
    code: string,
    state: string
  ): Promise<TokenResponse> {
    // çŠ¶æ…‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ¤œè¨¼ï¼ˆCSRFå¯¾ç­–ï¼‰
    const storedState = this.getStoredAuthState();
    if (!storedState || storedState.state !== state) {
      throw new SecurityError("Invalid state parameter", "CSRF_PROTECTION");
    }

    // èªè¨¼ã‚³ãƒ¼ãƒ‰ã‚’ãƒˆãƒ¼ã‚¯ãƒ³ã«äº¤æ›
    const tokens = await this.exchangeCodeForTokens(
      code,
      storedState.codeVerifier
    );

    // IDãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
    await this.validateIdToken(tokens.id_token, storedState.nonce);

    // ã‚»ã‚­ãƒ¥ã‚¢ã«ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜
    await this.securelyStoreTokens(tokens);

    // èªè¨¼çŠ¶æ…‹ã‚’ã‚¯ãƒªã‚¢
    this.clearAuthState();

    return tokens;
  }

  /**
   * IDãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
   * @param idToken IDãƒˆãƒ¼ã‚¯ãƒ³
   * @param expectedNonce æœŸå¾…ã•ã‚Œã‚‹ãƒãƒ³ã‚¹
   */
  private async validateIdToken(
    idToken: string,
    expectedNonce: string
  ): Promise<void> {
    try {
      // JWTã®ç½²åæ¤œè¨¼
      const payload = await this.verifyJwtSignature(idToken);

      // åŸºæœ¬çš„ãªã‚¯ãƒ¬ãƒ¼ãƒ ã®æ¤œè¨¼
      if (payload.iss !== "https://accounts.google.com") {
        throw new SecurityError("Invalid issuer", "TOKEN_VALIDATION");
      }

      if (payload.aud !== process.env.GOOGLE_CLIENT_ID) {
        throw new SecurityError("Invalid audience", "TOKEN_VALIDATION");
      }

      if (payload.exp < Date.now() / 1000) {
        throw new SecurityError("Token expired", "TOKEN_VALIDATION");
      }

      if (payload.nonce !== expectedNonce) {
        throw new SecurityError("Invalid nonce", "TOKEN_VALIDATION");
      }
    } catch (error) {
      throw new SecurityError(
        "ID token validation failed",
        "TOKEN_VALIDATION",
        error
      );
    }
  }

  /**
   * ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ©ãƒ³ãƒ€ãƒ æ–‡å­—åˆ—ç”Ÿæˆ
   * @param length é•·ã•
   * @returns ãƒ©ãƒ³ãƒ€ãƒ æ–‡å­—åˆ—
   */
  private generateSecureRandom(length: number): string {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    return Array.from(array, (byte) => byte.toString(16).padStart(2, "0")).join(
      ""
    );
  }

  /**
   * PKCE code verifierç”Ÿæˆ
   * @returns code verifier
   */
  private generateCodeVerifier(): string {
    const array = new Uint8Array(32);
    crypto.getRandomValues(array);
    return btoa(String.fromCharCode.apply(null, Array.from(array)))
      .replace(/\+/g, "-")
      .replace(/\//g, "_")
      .replace(/=/g, "");
  }

  /**
   * PKCE code challengeç”Ÿæˆ
   * @param verifier code verifier
   * @returns code challenge
   */
  private async generateCodeChallenge(verifier: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(verifier);
    const digest = await crypto.subtle.digest("SHA-256", data);
    return btoa(
      String.fromCharCode.apply(null, Array.from(new Uint8Array(digest)))
    )
      .replace(/\+/g, "-")
      .replace(/\//g, "_")
      .replace(/=/g, "");
  }
}

/**
 * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¨ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹
 */
class SecurityError extends Error {
  constructor(
    message: string,
    public code: string,
    public originalError?: any
  ) {
    super(message);
    this.name = "SecurityError";
  }
}
```

### å¤šè¦ç´ èªè¨¼ï¼ˆMFAï¼‰

```typescript
/**
 * å¤šè¦ç´ èªè¨¼å®Ÿè£…
 */
class MFAManager {
  /**
   * TOTPï¼ˆTime-based One-Time Passwordï¼‰ã®ç”Ÿæˆ
   * @param secret å…±æœ‰ç§˜å¯†éµ
   * @returns TOTP
   */
  generateTOTP(secret: string): string {
    const time = Math.floor(Date.now() / 1000 / 30); // 30ç§’é–“éš”
    const hmac = this.hmacSHA1(secret, time);
    const offset = hmac[hmac.length - 1] & 0xf;
    const code =
      (((hmac[offset] & 0x7f) << 24) |
        ((hmac[offset + 1] & 0xff) << 16) |
        ((hmac[offset + 2] & 0xff) << 8) |
        (hmac[offset + 3] & 0xff)) %
      1000000;

    return code.toString().padStart(6, "0");
  }

  /**
   * TOTPã®æ¤œè¨¼
   * @param token å…¥åŠ›ã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³
   * @param secret å…±æœ‰ç§˜å¯†éµ
   * @param window æ™‚é–“çª“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ1 = Â±30ç§’ï¼‰
   * @returns æ¤œè¨¼çµæœ
   */
  verifyTOTP(token: string, secret: string, window: number = 1): boolean {
    const currentTime = Math.floor(Date.now() / 1000 / 30);

    for (let i = -window; i <= window; i++) {
      const time = currentTime + i;
      const expectedToken = this.generateTOTPForTime(secret, time);
      if (token === expectedToken) {
        return true;
      }
    }

    return false;
  }

  /**
   * ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚³ãƒ¼ãƒ‰ã®ç”Ÿæˆ
   * @returns ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚³ãƒ¼ãƒ‰é…åˆ—
   */
  generateBackupCodes(): string[] {
    const codes: string[] = [];
    for (let i = 0; i < 10; i++) {
      const code = this.generateSecureRandom(8);
      codes.push(code);
    }
    return codes;
  }
}
```

## ãƒ‡ãƒ¼ã‚¿ä¿è­·

### æš—å·åŒ–

```typescript
/**
 * ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–ç®¡ç†
 */
class EncryptionManager {
  private readonly algorithm = "AES-GCM";
  private readonly keyLength = 256;

  /**
   * ãƒ‡ãƒ¼ã‚¿ã‚’æš—å·åŒ–
   * @param data å¹³æ–‡ãƒ‡ãƒ¼ã‚¿
   * @param key æš—å·åŒ–ã‚­ãƒ¼
   * @returns æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
   */
  async encrypt(data: string, key: CryptoKey): Promise<EncryptedData> {
    const encoder = new TextEncoder();
    const plaintext = encoder.encode(data);

    // ãƒ©ãƒ³ãƒ€ãƒ ãªIVã‚’ç”Ÿæˆ
    const iv = crypto.getRandomValues(new Uint8Array(12));

    // ãƒ‡ãƒ¼ã‚¿ã‚’æš—å·åŒ–
    const ciphertext = await crypto.subtle.encrypt(
      {
        name: this.algorithm,
        iv: iv,
      },
      key,
      plaintext
    );

    return {
      ciphertext: new Uint8Array(ciphertext),
      iv: iv,
      algorithm: this.algorithm,
    };
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å·åŒ–
   * @param encryptedData æš—å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
   * @param key å¾©å·åŒ–ã‚­ãƒ¼
   * @returns å¹³æ–‡ãƒ‡ãƒ¼ã‚¿
   */
  async decrypt(encryptedData: EncryptedData, key: CryptoKey): Promise<string> {
    const plaintext = await crypto.subtle.decrypt(
      {
        name: encryptedData.algorithm,
        iv: encryptedData.iv,
      },
      key,
      encryptedData.ciphertext
    );

    const decoder = new TextDecoder();
    return decoder.decode(plaintext);
  }

  /**
   * æš—å·åŒ–ã‚­ãƒ¼ã‚’ç”Ÿæˆ
   * @returns æš—å·åŒ–ã‚­ãƒ¼
   */
  async generateKey(): Promise<CryptoKey> {
    return await crypto.subtle.generateKey(
      {
        name: this.algorithm,
        length: this.keyLength,
      },
      true, // extractable
      ["encrypt", "decrypt"]
    );
  }

  /**
   * ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹ã®ã‚­ãƒ¼å°å‡º
   * @param password ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
   * @param salt ã‚½ãƒ«ãƒˆ
   * @returns å°å‡ºã•ã‚ŒãŸã‚­ãƒ¼
   */
  async deriveKeyFromPassword(
    password: string,
    salt: Uint8Array
  ): Promise<CryptoKey> {
    const encoder = new TextEncoder();
    const passwordBuffer = encoder.encode(password);

    // PBKDF2ã§ã‚­ãƒ¼ã‚’å°å‡º
    const baseKey = await crypto.subtle.importKey(
      "raw",
      passwordBuffer,
      "PBKDF2",
      false,
      ["deriveKey"]
    );

    return await crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt: salt,
        iterations: 100000, // 10ä¸‡å›
        hash: "SHA-256",
      },
      baseKey,
      {
        name: this.algorithm,
        length: this.keyLength,
      },
      false,
      ["encrypt", "decrypt"]
    );
  }
}

/**
 * æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã®å‹å®šç¾©
 */
interface EncryptedData {
  ciphertext: Uint8Array;
  iv: Uint8Array;
  algorithm: string;
}
```

### å€‹äººæƒ…å ±ä¿è­·

```typescript
/**
 * å€‹äººæƒ…å ±ä¿è­·ç®¡ç†
 */
class PIIProtectionManager {
  private readonly sensitiveFields = [
    "name",
    "email",
    "phone",
    "address",
    "employeeId",
  ];

  /**
   * å€‹äººæƒ…å ±ã‚’ãƒã‚¹ã‚¯
   * @param data ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @returns ãƒã‚¹ã‚¯ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
   */
  maskPII(data: Record<string, any>): Record<string, any> {
    const masked = { ...data };

    for (const field of this.sensitiveFields) {
      if (masked[field]) {
        masked[field] = this.maskValue(masked[field], field);
      }
    }

    return masked;
  }

  /**
   * å€¤ã‚’ãƒã‚¹ã‚¯
   * @param value å…ƒã®å€¤
   * @param fieldType ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚¿ã‚¤ãƒ—
   * @returns ãƒã‚¹ã‚¯ã•ã‚ŒãŸå€¤
   */
  private maskValue(value: string, fieldType: string): string {
    switch (fieldType) {
      case "email":
        const [local, domain] = value.split("@");
        return `${local.charAt(0)}***@${domain}`;

      case "phone":
        return value.replace(/.(?=.{4})/g, "*");

      case "name":
        return value.charAt(0) + "*".repeat(value.length - 1);

      default:
        return "*".repeat(value.length);
    }
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿åŒ¿ååŒ–
   * @param data ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @returns åŒ¿ååŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
   */
  anonymizeData(data: Record<string, any>): Record<string, any> {
    const anonymized = { ...data };

    // ç›´æ¥è­˜åˆ¥å­ã‚’å‰Šé™¤
    delete anonymized.name;
    delete anonymized.email;
    delete anonymized.employeeId;

    // æº–è­˜åˆ¥å­ã‚’ä¸€èˆ¬åŒ–
    if (anonymized.birthDate) {
      anonymized.birthYear = new Date(anonymized.birthDate).getFullYear();
      delete anonymized.birthDate;
    }

    if (anonymized.address) {
      // ä½æ‰€ã‚’å¸‚åŒºç”ºæ‘ãƒ¬ãƒ™ãƒ«ã¾ã§ä¸€èˆ¬åŒ–
      anonymized.city = this.extractCity(anonymized.address);
      delete anonymized.address;
    }

    return anonymized;
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ä»®ååŒ–
   * @param data ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @param key ä»®ååŒ–ã‚­ãƒ¼
   * @returns ä»®ååŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿
   */
  async pseudonymizeData(
    data: Record<string, any>,
    key: string
  ): Promise<Record<string, any>> {
    const pseudonymized = { ...data };

    for (const field of this.sensitiveFields) {
      if (pseudonymized[field]) {
        pseudonymized[field] = await this.generatePseudonym(
          pseudonymized[field],
          key
        );
      }
    }

    return pseudonymized;
  }

  /**
   * ä»®åã‚’ç”Ÿæˆ
   * @param value å…ƒã®å€¤
   * @param key ä»®ååŒ–ã‚­ãƒ¼
   * @returns ä»®å
   */
  private async generatePseudonym(value: string, key: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(value + key);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = new Uint8Array(hashBuffer);
    return Array.from(hashArray, (byte) =>
      byte.toString(16).padStart(2, "0")
    ).join("");
  }
}
```

## é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### HTTPS/TLSè¨­å®š

```typescript
/**
 * TLS/SSLè¨­å®š
 */
const TLS_CONFIG = {
  // æœ€å°TLSãƒãƒ¼ã‚¸ãƒ§ãƒ³
  minVersion: "TLSv1.2",

  // æ¨å¥¨æš—å·ã‚¹ã‚¤ãƒ¼ãƒˆ
  cipherSuites: [
    "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
    "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
  ],

  // HSTSè¨­å®š
  hsts: {
    maxAge: 31536000, // 1å¹´
    includeSubDomains: true,
    preload: true,
  },

  // è¨¼æ˜æ›¸ãƒ”ãƒ‹ãƒ³ã‚°
  certificatePinning: {
    enabled: true,
    pins: [
      "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
      "sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=",
    ],
  },
} as const;

/**
 * ã‚»ã‚­ãƒ¥ã‚¢HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
 */
class SecureHttpClient {
  private readonly defaultHeaders = {
    "Strict-Transport-Security": `max-age=${TLS_CONFIG.hsts.maxAge}; includeSubDomains; preload`,
    "X-Content-Type-Options": "nosniff",
    "X-Frame-Options": "DENY",
    "X-XSS-Protection": "1; mode=block",
    "Referrer-Policy": "strict-origin-when-cross-origin",
  };

  /**
   * ã‚»ã‚­ãƒ¥ã‚¢ãªHTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆ
   * @param url ãƒªã‚¯ã‚¨ã‚¹ãƒˆURL
   * @param options ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
   * @returns ãƒ¬ã‚¹ãƒãƒ³ã‚¹
   */
  async secureRequest(
    url: string,
    options: RequestInit = {}
  ): Promise<Response> {
    // HTTPSã®å¼·åˆ¶
    if (!url.startsWith("https://")) {
      throw new SecurityError("HTTPS required", "INSECURE_PROTOCOL");
    }

    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ 
    const secureOptions: RequestInit = {
      ...options,
      headers: {
        ...this.defaultHeaders,
        ...options.headers,
      },
      // èªè¨¼æƒ…å ±ã®é€ä¿¡ã‚’åˆ¶é™
      credentials: "same-origin",
      // ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆã®åˆ¶é™
      redirect: "error",
    };

    try {
      const response = await fetch(url, secureOptions);

      // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼
      await this.validateResponse(response);

      return response;
    } catch (error) {
      throw new SecurityError("Secure request failed", "REQUEST_FAILED", error);
    }
  }

  /**
   * ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ¤œè¨¼
   * @param response HTTPãƒ¬ã‚¹ãƒãƒ³ã‚¹
   */
  private async validateResponse(response: Response): Promise<void> {
    // Content-Typeã®æ¤œè¨¼
    const contentType = response.headers.get("Content-Type");
    if (contentType && !this.isAllowedContentType(contentType)) {
      throw new SecurityError(
        "Invalid content type",
        "CONTENT_TYPE_VALIDATION"
      );
    }

    // CSPãƒ˜ãƒƒãƒ€ãƒ¼ã®æ¤œè¨¼
    const csp = response.headers.get("Content-Security-Policy");
    if (!csp) {
      console.warn("Missing Content-Security-Policy header");
    }

    // X-Frame-Optionsã®æ¤œè¨¼
    const frameOptions = response.headers.get("X-Frame-Options");
    if (!frameOptions || frameOptions.toLowerCase() !== "deny") {
      console.warn("Missing or weak X-Frame-Options header");
    }
  }

  /**
   * è¨±å¯ã•ã‚ŒãŸContent-Typeã‹ãƒã‚§ãƒƒã‚¯
   * @param contentType Content-Type
   * @returns è¨±å¯ãƒ•ãƒ©ã‚°
   */
  private isAllowedContentType(contentType: string): boolean {
    const allowedTypes = [
      "application/json",
      "text/html",
      "text/css",
      "application/javascript",
      "image/png",
      "image/jpeg",
      "image/svg+xml",
    ];

    return allowedTypes.some((type) => contentType.startsWith(type));
  }
}
```

### Content Security Policy (CSP)

```typescript
/**
 * CSPè¨­å®š
 */
const CSP_CONFIG = {
  // åŸºæœ¬ãƒãƒªã‚·ãƒ¼
  "default-src": ["'self'"],

  // ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚½ãƒ¼ã‚¹
  "script-src": [
    "'self'",
    "'unsafe-inline'", // é–‹ç™ºæ™‚ã®ã¿ã€æœ¬ç•ªã§ã¯å‰Šé™¤
    "https://apis.google.com",
    "https://accounts.google.com",
  ],

  // ã‚¹ã‚¿ã‚¤ãƒ«ã‚½ãƒ¼ã‚¹
  "style-src": ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],

  // ç”»åƒã‚½ãƒ¼ã‚¹
  "img-src": ["'self'", "data:", "https:"],

  // ãƒ•ã‚©ãƒ³ãƒˆã‚½ãƒ¼ã‚¹
  "font-src": ["'self'", "https://fonts.gstatic.com"],

  // æ¥ç¶šå…ˆ
  "connect-src": [
    "'self'",
    "https://script.google.com",
    "https://accounts.google.com",
    "https://oauth2.googleapis.com",
  ],

  // ãƒ•ãƒ¬ãƒ¼ãƒ ã‚½ãƒ¼ã‚¹
  "frame-src": ["https://accounts.google.com"],

  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚½ãƒ¼ã‚¹
  "object-src": ["'none'"],

  // ãƒ™ãƒ¼ã‚¹URI
  "base-uri": ["'self'"],

  // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡å…ˆ
  "form-action": ["'self'"],

  // ãƒ•ãƒ¬ãƒ¼ãƒ ç¥–å…ˆ
  "frame-ancestors": ["'none'"],

  // ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰éã‚»ã‚­ãƒ¥ã‚¢è¦æ±‚
  "upgrade-insecure-requests": true,

  // ãƒ–ãƒ­ãƒƒã‚¯æ™‚ã®å ±å‘Šå…ˆ
  "report-uri": "/api/csp-report",
} as const;

/**
 * CSPãƒ˜ãƒƒãƒ€ãƒ¼ç”Ÿæˆ
 * @returns CSPãƒ˜ãƒƒãƒ€ãƒ¼æ–‡å­—åˆ—
 */
function generateCSPHeader(): string {
  const directives: string[] = [];

  for (const [directive, sources] of Object.entries(CSP_CONFIG)) {
    if (directive === "upgrade-insecure-requests") {
      if (sources) {
        directives.push("upgrade-insecure-requests");
      }
    } else if (Array.isArray(sources)) {
      directives.push(`${directive} ${sources.join(" ")}`);
    } else {
      directives.push(`${directive} ${sources}`);
    }
  }

  return directives.join("; ");
}
```

## å…¥åŠ›æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

```typescript
/**
 * å…¥åŠ›æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
 */
class InputValidator {
  private readonly patterns = {
    email: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
    time: /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/,
    date: /^\d{4}-\d{2}-\d{2}$/,
    employeeId: /^[A-Z0-9]{6,10}$/,
    name: /^[\p{L}\p{M}\s'-]{1,50}$/u,
  };

  private readonly maxLengths = {
    name: 50,
    email: 100,
    notes: 500,
    workLocation: 100,
  };

  /**
   * å…¥åŠ›å€¤ã‚’æ¤œè¨¼
   * @param field ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å
   * @param value å…¥åŠ›å€¤
   * @returns æ¤œè¨¼çµæœ
   */
  validate(field: string, value: any): ValidationResult {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      sanitizedValue: value,
    };

    // null/undefined ãƒã‚§ãƒƒã‚¯
    if (value == null) {
      result.isValid = false;
      result.errors.push("Value is required");
      return result;
    }

    // æ–‡å­—åˆ—ã®å ´åˆ
    if (typeof value === "string") {
      // é•·ã•ãƒã‚§ãƒƒã‚¯
      const maxLength = this.maxLengths[field as keyof typeof this.maxLengths];
      if (maxLength && value.length > maxLength) {
        result.isValid = false;
        result.errors.push(`Value exceeds maximum length of ${maxLength}`);
      }

      // ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
      const pattern = this.patterns[field as keyof typeof this.patterns];
      if (pattern && !pattern.test(value)) {
        result.isValid = false;
        result.errors.push(`Invalid format for ${field}`);
      }

      // ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
      result.sanitizedValue = this.sanitizeString(value);
    }

    // æ•°å€¤ã®å ´åˆ
    if (typeof value === "number") {
      if (!Number.isFinite(value)) {
        result.isValid = false;
        result.errors.push("Value must be a finite number");
      }

      // ç¯„å›²ãƒã‚§ãƒƒã‚¯
      if (field === "breakTime" && (value < 0 || value > 480)) {
        // 8æ™‚é–“ã¾ã§
        result.isValid = false;
        result.errors.push("Break time must be between 0 and 480 minutes");
      }
    }

    return result;
  }

  /**
   * æ–‡å­—åˆ—ã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚º
   * @param input å…¥åŠ›æ–‡å­—åˆ—
   * @returns ã‚µãƒ‹ã‚¿ã‚¤ã‚ºæ¸ˆã¿æ–‡å­—åˆ—
   */
  private sanitizeString(input: string): string {
    return (
      input
        // HTMLã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#x27;")
        .replace(/\//g, "&#x2F;")
        // åˆ¶å¾¡æ–‡å­—ã‚’å‰Šé™¤
        .replace(/[\x00-\x1F\x7F]/g, "")
        // å…ˆé ­ãƒ»æœ«å°¾ã®ç©ºç™½ã‚’å‰Šé™¤
        .trim()
    );
  }

  /**
   * SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
   * @param input å…¥åŠ›æ–‡å­—åˆ—
   * @returns ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—æ¸ˆã¿æ–‡å­—åˆ—
   */
  escapeSql(input: string): string {
    return input.replace(/'/g, "''");
  }

  /**
   * XSSå¯¾ç­–
   * @param input å…¥åŠ›æ–‡å­—åˆ—
   * @returns ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—æ¸ˆã¿æ–‡å­—åˆ—
   */
  escapeHtml(input: string): string {
    const div = document.createElement("div");
    div.textContent = input;
    return div.innerHTML;
  }
}

/**
 * æ¤œè¨¼çµæœã®å‹å®šç¾©
 */
interface ValidationResult {
  isValid: boolean;
  errors: string[];
  sanitizedValue: any;
}
```

## ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

```typescript
/**
 * ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆRBACï¼‰
 */
class AccessControlManager {
  private readonly roles = {
    user: {
      permissions: [
        "kintai:read:own",
        "kintai:create:own",
        "kintai:update:own",
        "profile:read:own",
        "profile:update:own",
      ],
    },
    manager: {
      permissions: [
        "kintai:read:team",
        "kintai:approve:team",
        "report:read:team",
        "user:read:team",
      ],
      inherits: ["user"],
    },
    admin: {
      permissions: ["kintai:*", "user:*", "system:*", "audit:*"],
      inherits: ["manager"],
    },
    readonly: {
      permissions: ["kintai:read:own", "profile:read:own"],
    },
  };

  /**
   * æ¨©é™ã‚’ãƒã‚§ãƒƒã‚¯
   * @param user ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±
   * @param resource ãƒªã‚½ãƒ¼ã‚¹
   * @param action ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
   * @param context ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @returns è¨±å¯ãƒ•ãƒ©ã‚°
   */
  checkPermission(
    user: { id: string; role: string },
    resource: string,
    action: string,
    context?: { ownerId?: string; teamId?: string }
  ): boolean {
    const userPermissions = this.getUserPermissions(user.role);

    // å®Œå…¨ä¸€è‡´ãƒã‚§ãƒƒã‚¯
    const exactPermission = `${resource}:${action}`;
    if (userPermissions.includes(exactPermission)) {
      return true;
    }

    // ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ãƒã‚§ãƒƒã‚¯
    const wildcardPermission = `${resource}:*`;
    if (userPermissions.includes(wildcardPermission)) {
      return true;
    }

    // ã‚¹ã‚³ãƒ¼ãƒ—ä»˜ãæ¨©é™ãƒã‚§ãƒƒã‚¯
    const ownPermission = `${resource}:${action}:own`;
    if (
      userPermissions.includes(ownPermission) &&
      context?.ownerId === user.id
    ) {
      return true;
    }

    const teamPermission = `${resource}:${action}:team`;
    if (
      userPermissions.includes(teamPermission) &&
      this.isInSameTeam(user.id, context?.ownerId)
    ) {
      return true;
    }

    return false;
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¨æ¨©é™ã‚’å–å¾—
   * @param role ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«
   * @returns æ¨©é™é…åˆ—
   */
  private getUserPermissions(role: string): string[] {
    const roleConfig = this.roles[role as keyof typeof this.roles];
    if (!roleConfig) {
      return [];
    }

    let permissions = [...roleConfig.permissions];

    // ç¶™æ‰¿ã•ã‚ŒãŸãƒ­ãƒ¼ãƒ«ã®æ¨©é™ã‚’è¿½åŠ 
    if (roleConfig.inherits) {
      for (const inheritedRole of roleConfig.inherits) {
        permissions = permissions.concat(
          this.getUserPermissions(inheritedRole)
        );
      }
    }

    return [...new Set(permissions)]; // é‡è¤‡ã‚’é™¤å»
  }

  /**
   * åŒã˜ãƒãƒ¼ãƒ ã‹ãƒã‚§ãƒƒã‚¯
   * @param userId1 ãƒ¦ãƒ¼ã‚¶ãƒ¼ID1
   * @param userId2 ãƒ¦ãƒ¼ã‚¶ãƒ¼ID2
   * @returns åŒã˜ãƒãƒ¼ãƒ ãƒ•ãƒ©ã‚°
   */
  private isInSameTeam(userId1?: string, userId2?: string): boolean {
    if (!userId1 || !userId2) {
      return false;
    }

    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒãƒ¼ãƒ æƒ…å ±ã‚’å–å¾—ã—ã¦æ¯”è¼ƒ
    // ã“ã“ã§ã¯ç°¡ç•¥åŒ–
    return true;
  }
}

/**
 * å±æ€§ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆABACï¼‰
 */
class AttributeBasedAccessControl {
  /**
   * ãƒãƒªã‚·ãƒ¼ã‚’è©•ä¾¡
   * @param subject ä¸»ä½“ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼‰
   * @param resource ãƒªã‚½ãƒ¼ã‚¹
   * @param action ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
   * @param environment ç’°å¢ƒ
   * @returns è¨±å¯ãƒ•ãƒ©ã‚°
   */
  evaluatePolicy(
    subject: Record<string, any>,
    resource: Record<string, any>,
    action: string,
    environment: Record<string, any>
  ): boolean {
    // æ™‚é–“ãƒ™ãƒ¼ã‚¹ã®åˆ¶å¾¡
    if (!this.checkTimeConstraints(environment.currentTime)) {
      return false;
    }

    // å ´æ‰€ãƒ™ãƒ¼ã‚¹ã®åˆ¶å¾¡
    if (!this.checkLocationConstraints(environment.clientIP)) {
      return false;
    }

    // ãƒ‡ãƒ¼ã‚¿åˆ†é¡ãƒ™ãƒ¼ã‚¹ã®åˆ¶å¾¡
    if (!this.checkDataClassification(subject, resource)) {
      return false;
    }

    // ãƒªã‚¹ã‚¯ãƒ™ãƒ¼ã‚¹ã®åˆ¶å¾¡
    if (!this.checkRiskLevel(subject, action, environment)) {
      return false;
    }

    return true;
  }

  /**
   * æ™‚é–“åˆ¶ç´„ã‚’ãƒã‚§ãƒƒã‚¯
   * @param currentTime ç¾åœ¨æ™‚åˆ»
   * @returns è¨±å¯ãƒ•ãƒ©ã‚°
   */
  private checkTimeConstraints(currentTime: Date): boolean {
    const hour = currentTime.getHours();
    const day = currentTime.getDay();

    // å–¶æ¥­æ™‚é–“å†…ï¼ˆå¹³æ—¥9-18æ™‚ï¼‰ã®ã¿è¨±å¯
    if (day >= 1 && day <= 5 && hour >= 9 && hour < 18) {
      return true;
    }

    return false;
  }

  /**
   * å ´æ‰€åˆ¶ç´„ã‚’ãƒã‚§ãƒƒã‚¯
   * @param clientIP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆIP
   * @returns è¨±å¯ãƒ•ãƒ©ã‚°
   */
  private checkLocationConstraints(clientIP: string): boolean {
    // è¨±å¯ã•ã‚ŒãŸIPãƒ¬ãƒ³ã‚¸
    const allowedRanges = ["192.168.1.0/24", "10.0.0.0/8"];

    return allowedRanges.some((range) => this.isIPInRange(clientIP, range));
  }

  /**
   * IPãŒç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
   * @param ip IPã‚¢ãƒ‰ãƒ¬ã‚¹
   * @param range IPç¯„å›²ï¼ˆCIDRè¨˜æ³•ï¼‰
   * @returns ç¯„å›²å†…ãƒ•ãƒ©ã‚°
   */
  private isIPInRange(ip: string, range: string): boolean {
    // ç°¡ç•¥åŒ–ã•ã‚ŒãŸå®Ÿè£…
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€é©åˆ‡ãªIPã‚¢ãƒ‰ãƒ¬ã‚¹è¨ˆç®—ã‚’è¡Œã†
    return true;
  }
}
```

## ç›£æŸ»ãƒ»ãƒ­ã‚°

```typescript
/**
 * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ãƒ­ã‚°
 */
class SecurityAuditLogger {
  private readonly logLevels = {
    INFO: "info",
    WARN: "warn",
    ERROR: "error",
    CRITICAL: "critical",
  } as const;

  /**
   * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒ­ã‚°
   * @param event ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆ
   */
  async logSecurityEvent(event: SecurityEvent): Promise<void> {
    const logEntry: SecurityLogEntry = {
      timestamp: new Date().toISOString(),
      eventId: this.generateEventId(),
      eventType: event.type,
      severity: event.severity,
      userId: event.userId,
      sessionId: event.sessionId,
      ipAddress: event.ipAddress,
      userAgent: event.userAgent,
      resource: event.resource,
      action: event.action,
      result: event.result,
      details: event.details,
      riskScore: this.calculateRiskScore(event),
    };

    // ãƒ­ã‚°ã‚’æ°¸ç¶šåŒ–
    await this.persistLog(logEntry);

    // é‡è¦åº¦ã«å¿œã˜ã¦ã‚¢ãƒ©ãƒ¼ãƒˆ
    if (event.severity === "critical" || event.severity === "high") {
      await this.sendSecurityAlert(logEntry);
    }

    // ç•°å¸¸æ¤œçŸ¥
    await this.detectAnomalies(logEntry);
  }

  /**
   * ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã‚’ãƒ­ã‚°
   * @param attempt ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œæƒ…å ±
   */
  async logLoginAttempt(attempt: LoginAttempt): Promise<void> {
    await this.logSecurityEvent({
      type: "authentication",
      severity: attempt.success ? "info" : "warn",
      userId: attempt.userId,
      sessionId: attempt.sessionId,
      ipAddress: attempt.ipAddress,
      userAgent: attempt.userAgent,
      resource: "auth",
      action: "login",
      result: attempt.success ? "success" : "failure",
      details: {
        method: attempt.method,
        failureReason: attempt.failureReason,
      },
    });
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ã‚’ãƒ­ã‚°
   * @param access ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹æƒ…å ±
   */
  async logDataAccess(access: DataAccess): Promise<void> {
    await this.logSecurityEvent({
      type: "data_access",
      severity: "info",
      userId: access.userId,
      sessionId: access.sessionId,
      ipAddress: access.ipAddress,
      userAgent: access.userAgent,
      resource: access.resource,
      action: access.action,
      result: "success",
      details: {
        recordCount: access.recordCount,
        dataClassification: access.dataClassification,
      },
    });
  }

  /**
   * æ¨©é™é•åã‚’ãƒ­ã‚°
   * @param violation æ¨©é™é•åæƒ…å ±
   */
  async logPermissionViolation(violation: PermissionViolation): Promise<void> {
    await this.logSecurityEvent({
      type: "authorization",
      severity: "high",
      userId: violation.userId,
      sessionId: violation.sessionId,
      ipAddress: violation.ipAddress,
      userAgent: violation.userAgent,
      resource: violation.resource,
      action: violation.action,
      result: "denied",
      details: {
        requiredPermission: violation.requiredPermission,
        userPermissions: violation.userPermissions,
      },
    });
  }

  /**
   * ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
   * @param event ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆ
   * @returns ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ï¼ˆ0-100ï¼‰
   */
  private calculateRiskScore(event: SecurityEvent): number {
    let score = 0;

    // é‡è¦åº¦ã«ã‚ˆã‚‹åŸºæœ¬ã‚¹ã‚³ã‚¢
    switch (event.severity) {
      case "critical":
        score += 80;
        break;
      case "high":
        score += 60;
        break;
      case "medium":
        score += 40;
        break;
      case "low":
        score += 20;
        break;
      default:
        score += 10;
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹èª¿æ•´
    switch (event.type) {
      case "authentication":
        if (event.result === "failure") score += 20;
        break;
      case "authorization":
        if (event.result === "denied") score += 30;
        break;
      case "data_access":
        if (event.details?.dataClassification === "sensitive") score += 15;
        break;
    }

    // æ™‚é–“å¸¯ã«ã‚ˆã‚‹èª¿æ•´ï¼ˆå–¶æ¥­æ™‚é–“å¤–ã¯+10ï¼‰
    const hour = new Date().getHours();
    if (hour < 9 || hour > 18) {
      score += 10;
    }

    return Math.min(score, 100);
  }

  /**
   * ç•°å¸¸æ¤œçŸ¥
   * @param logEntry ãƒ­ã‚°ã‚¨ãƒ³ãƒˆãƒª
   */
  private async detectAnomalies(logEntry: SecurityLogEntry): Promise<void> {
    // çŸ­æ™‚é–“ã§ã®å¤§é‡ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—
    if (
      logEntry.eventType === "authentication" &&
      logEntry.result === "failure"
    ) {
      const recentFailures = await this.getRecentLoginFailures(
        logEntry.userId,
        300
      ); // 5åˆ†é–“
      if (recentFailures >= 5) {
        await this.sendSecurityAlert({
          ...logEntry,
          severity: "critical",
          details: {
            ...logEntry.details,
            anomaly: "Multiple login failures detected",
            failureCount: recentFailures,
          },
        });
      }
    }

    // ç•°å¸¸ãªæ™‚é–“å¸¯ã§ã®ã‚¢ã‚¯ã‚»ã‚¹
    const hour = new Date().getHours();
    if ((hour < 6 || hour > 22) && logEntry.eventType === "data_access") {
      await this.sendSecurityAlert({
        ...logEntry,
        severity: "medium",
        details: {
          ...logEntry.details,
          anomaly: "Unusual access time detected",
        },
      });
    }
  }

  /**
   * ã‚¤ãƒ™ãƒ³ãƒˆIDã‚’ç”Ÿæˆ
   * @returns ã‚¤ãƒ™ãƒ³ãƒˆID
   */
  private generateEventId(): string {
    return `sec_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }
}

/**
 * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã®å‹å®šç¾©
 */
interface SecurityEvent {
  type:
    | "authentication"
    | "authorization"
    | "data_access"
    | "system"
    | "privacy";
  severity: "info" | "low" | "medium" | "high" | "critical";
  userId?: string;
  sessionId?: string;
  ipAddress?: string;
  userAgent?: string;
  resource?: string;
  action?: string;
  result?: "success" | "failure" | "denied";
  details?: Record<string, any>;
}

interface SecurityLogEntry extends SecurityEvent {
  timestamp: string;
  eventId: string;
  eventType: string;
  riskScore: number;
}
```

## GDPRãƒ»ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼å¯¾å¿œ

```typescript
/**
 * GDPRå¯¾å¿œç®¡ç†
 */
class GDPRComplianceManager {
  /**
   * åŒæ„ç®¡ç†
   * @param userId ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @param consentType åŒæ„ã‚¿ã‚¤ãƒ—
   * @param granted åŒæ„ãƒ•ãƒ©ã‚°
   */
  async recordConsent(
    userId: string,
    consentType: ConsentType,
    granted: boolean
  ): Promise<void> {
    const consentRecord: ConsentRecord = {
      userId,
      consentType,
      granted,
      timestamp: new Date().toISOString(),
      ipAddress: this.getCurrentIP(),
      userAgent: navigator.userAgent,
      version: "1.0",
    };

    await this.storeConsentRecord(consentRecord);
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ãƒãƒ¼ã‚¿ãƒ“ãƒªãƒ†ã‚£ï¼ˆãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼‰
   * @param userId ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @returns ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿
   */
  async exportUserData(userId: string): Promise<UserDataExport> {
    const userData = await this.collectUserData(userId);

    return {
      exportDate: new Date().toISOString(),
      userId,
      personalData: {
        profile: userData.profile,
        preferences: userData.preferences,
        kintaiRecords: userData.kintaiRecords,
      },
      metadata: {
        dataRetentionPeriod: "7 years",
        lastUpdated: userData.lastUpdated,
        dataClassification: "personal",
      },
    };
  }

  /**
   * å¿˜ã‚Œã‚‰ã‚Œã‚‹æ¨©åˆ©ï¼ˆãƒ‡ãƒ¼ã‚¿å‰Šé™¤ï¼‰
   * @param userId ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @param reason å‰Šé™¤ç†ç”±
   */
  async deleteUserData(userId: string, reason: string): Promise<void> {
    // æ³•çš„ä¿æŒç¾©å‹™ã®ãƒã‚§ãƒƒã‚¯
    const retentionCheck = await this.checkLegalRetention(userId);
    if (retentionCheck.mustRetain) {
      throw new Error(`Cannot delete data: ${retentionCheck.reason}`);
    }

    // ãƒ‡ãƒ¼ã‚¿å‰Šé™¤ã®å®Ÿè¡Œ
    await this.performDataDeletion(userId);

    // å‰Šé™¤ãƒ­ã‚°ã®è¨˜éŒ²
    await this.logDataDeletion(userId, reason);
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ä¿®æ­£æ¨©
   * @param userId ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @param corrections ä¿®æ­£ãƒ‡ãƒ¼ã‚¿
   */
  async correctUserData(
    userId: string,
    corrections: Record<string, any>
  ): Promise<void> {
    // ä¿®æ­£å‰ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    const originalData = await this.backupUserData(userId);

    // ãƒ‡ãƒ¼ã‚¿ã®ä¿®æ­£
    await this.updateUserData(userId, corrections);

    // ä¿®æ­£ãƒ­ã‚°ã®è¨˜éŒ²
    await this.logDataCorrection(userId, originalData, corrections);
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã®åˆ¶é™
   * @param userId ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
   * @param restriction åˆ¶é™ã‚¿ã‚¤ãƒ—
   */
  async restrictDataProcessing(
    userId: string,
    restriction: ProcessingRestriction
  ): Promise<void> {
    await this.updateProcessingRestrictions(userId, restriction);
    await this.logProcessingRestriction(userId, restriction);
  }
}

/**
 * åŒæ„ã‚¿ã‚¤ãƒ—
 */
type ConsentType =
  | "data_processing"
  | "marketing"
  | "analytics"
  | "cookies"
  | "third_party_sharing";

/**
 * åŒæ„è¨˜éŒ²
 */
interface ConsentRecord {
  userId: string;
  consentType: ConsentType;
  granted: boolean;
  timestamp: string;
  ipAddress: string;
  userAgent: string;
  version: string;
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
 */
interface UserDataExport {
  exportDate: string;
  userId: string;
  personalData: {
    profile: any;
    preferences: any;
    kintaiRecords: any[];
  };
  metadata: {
    dataRetentionPeriod: string;
    lastUpdated: string;
    dataClassification: string;
  };
}
```

## ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ

```typescript
/**
 * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ
 */
class IncidentResponseManager {
  private readonly severityLevels = {
    P1: { name: "Critical", responseTime: 15, escalationTime: 30 }, // åˆ†
    P2: { name: "High", responseTime: 60, escalationTime: 120 },
    P3: { name: "Medium", responseTime: 240, escalationTime: 480 },
    P4: { name: "Low", responseTime: 1440, escalationTime: 2880 },
  } as const;

  /**
   * ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’å ±å‘Š
   * @param incident ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆæƒ…å ±
   */
  async reportIncident(incident: SecurityIncident): Promise<string> {
    const incidentId = this.generateIncidentId();

    const incidentRecord: IncidentRecord = {
      id: incidentId,
      ...incident,
      status: "open",
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      timeline: [
        {
          timestamp: new Date().toISOString(),
          action: "incident_reported",
          description: "Incident reported and assigned ID",
          actor: incident.reportedBy,
        },
      ],
    };

    // ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‚’è¨˜éŒ²
    await this.storeIncident(incidentRecord);

    // è‡ªå‹•å¯¾å¿œã®å®Ÿè¡Œ
    await this.executeAutomaticResponse(incidentRecord);

    // é€šçŸ¥ã®é€ä¿¡
    await this.notifyIncidentTeam(incidentRecord);

    return incidentId;
  }

  /**
   * è‡ªå‹•å¯¾å¿œã®å®Ÿè¡Œ
   * @param incident ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆè¨˜éŒ²
   */
  private async executeAutomaticResponse(
    incident: IncidentRecord
  ): Promise<void> {
    switch (incident.type) {
      case "brute_force_attack":
        await this.blockSuspiciousIP(incident.sourceIP);
        await this.lockUserAccount(incident.targetUser);
        break;

      case "data_breach":
        await this.isolateAffectedSystems(incident.affectedSystems);
        await this.enableEmergencyLogging();
        break;

      case "malware_detected":
        await this.quarantineAffectedFiles(incident.affectedFiles);
        await this.scanRelatedSystems();
        break;

      case "unauthorized_access":
        await this.revokeUserSessions(incident.targetUser);
        await this.requirePasswordReset(incident.targetUser);
        break;
    }
  }
}

/**
 * ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆæƒ…å ±ã®å‹å®šç¾©
 */
interface SecurityIncident {
  type:
    | "brute_force_attack"
    | "data_breach"
    | "malware_detected"
    | "unauthorized_access"
    | "system_compromise";
  severity: "P1" | "P2" | "P3" | "P4";
  description: string;
  reportedBy: string;
  sourceIP?: string;
  targetUser?: string;
  affectedSystems?: string[];
  affectedFiles?: string[];
  evidence?: string[];
}

interface IncidentRecord extends SecurityIncident {
  id: string;
  status: "open" | "investigating" | "contained" | "resolved" | "closed";
  createdAt: string;
  updatedAt: string;
  timeline: IncidentTimelineEntry[];
}

interface IncidentTimelineEntry {
  timestamp: string;
  action: string;
  description: string;
  actor: string;
}
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»

### å®šæœŸç›£æŸ»

```typescript
/**
 * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ç®¡ç†
 */
class SecurityAuditManager {
  /**
   * åŒ…æ‹¬çš„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã‚’å®Ÿè¡Œ
   * @returns ç›£æŸ»çµæœ
   */
  async performComprehensiveAudit(): Promise<AuditReport> {
    const auditResults: AuditResult[] = [];

    // èªè¨¼ãƒ»èªå¯ã®ç›£æŸ»
    auditResults.push(await this.auditAuthentication());
    auditResults.push(await this.auditAuthorization());

    // ãƒ‡ãƒ¼ã‚¿ä¿è­·ã®ç›£æŸ»
    auditResults.push(await this.auditDataProtection());
    auditResults.push(await this.auditEncryption());

    // ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã®ç›£æŸ»
    auditResults.push(await this.auditAccessControls());

    // ãƒ­ã‚°ãƒ»ç›£è¦–ã®ç›£æŸ»
    auditResults.push(await this.auditLogging());

    // è„†å¼±æ€§ã®ç›£æŸ»
    auditResults.push(await this.auditVulnerabilities());

    // ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ã®ç›£æŸ»
    auditResults.push(await this.auditCompliance());

    return this.generateAuditReport(auditResults);
  }

  /**
   * èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã®ç›£æŸ»
   * @returns ç›£æŸ»çµæœ
   */
  private async auditAuthentication(): Promise<AuditResult> {
    const findings: AuditFinding[] = [];

    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒªã‚·ãƒ¼ã®ãƒã‚§ãƒƒã‚¯
    const passwordPolicy = await this.checkPasswordPolicy();
    if (!passwordPolicy.isCompliant) {
      findings.push({
        severity: "medium",
        category: "authentication",
        description: "Password policy does not meet security requirements",
        recommendation: "Implement stronger password requirements",
      });
    }

    // MFAã®å®Ÿè£…çŠ¶æ³
    const mfaStatus = await this.checkMFAImplementation();
    if (!mfaStatus.isEnabled) {
      findings.push({
        severity: "high",
        category: "authentication",
        description: "Multi-factor authentication is not enabled",
        recommendation: "Implement MFA for all user accounts",
      });
    }

    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†
    const sessionSecurity = await this.checkSessionSecurity();
    if (!sessionSecurity.isSecure) {
      findings.push({
        severity: "medium",
        category: "authentication",
        description: "Session management has security weaknesses",
        recommendation: "Implement secure session management practices",
      });
    }

    return {
      category: "Authentication",
      status: findings.length === 0 ? "pass" : "fail",
      findings,
      score: this.calculateScore(findings),
    };
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ä¿è­·ã®ç›£æŸ»
   * @returns ç›£æŸ»çµæœ
   */
  private async auditDataProtection(): Promise<AuditResult> {
    const findings: AuditFinding[] = [];

    // æš—å·åŒ–ã®å®Ÿè£…
    const encryptionStatus = await this.checkEncryptionImplementation();
    if (!encryptionStatus.isProperlyImplemented) {
      findings.push({
        severity: "critical",
        category: "data_protection",
        description: "Data encryption is not properly implemented",
        recommendation: "Implement end-to-end encryption for sensitive data",
      });
    }

    // ãƒ‡ãƒ¼ã‚¿åˆ†é¡
    const dataClassification = await this.checkDataClassification();
    if (!dataClassification.isImplemented) {
      findings.push({
        severity: "medium",
        category: "data_protection",
        description: "Data classification system is not implemented",
        recommendation: "Implement data classification and labeling",
      });
    }

    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
    const backupSecurity = await this.checkBackupSecurity();
    if (!backupSecurity.isSecure) {
      findings.push({
        severity: "high",
        category: "data_protection",
        description: "Backup data is not properly secured",
        recommendation:
          "Implement secure backup encryption and access controls",
      });
    }

    return {
      category: "Data Protection",
      status: findings.length === 0 ? "pass" : "fail",
      findings,
      score: this.calculateScore(findings),
    };
  }
}

/**
 * ç›£æŸ»çµæœã®å‹å®šç¾©
 */
interface AuditResult {
  category: string;
  status: "pass" | "fail" | "warning";
  findings: AuditFinding[];
  score: number;
}

interface AuditFinding {
  severity: "low" | "medium" | "high" | "critical";
  category: string;
  description: string;
  recommendation: string;
}

interface AuditReport {
  auditDate: string;
  overallScore: number;
  status: "pass" | "fail";
  results: AuditResult[];
  summary: {
    totalFindings: number;
    criticalFindings: number;
    highFindings: number;
    mediumFindings: number;
    lowFindings: number;
  };
  recommendations: string[];
}
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š

### ç’°å¢ƒåˆ¥ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š

```typescript
/**
 * ç’°å¢ƒåˆ¥ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®š
 */
const SECURITY_CONFIGS = {
  development: {
    // é–‹ç™ºç’°å¢ƒè¨­å®š
    encryption: {
      enabled: true,
      algorithm: "AES-256-GCM",
      keyRotationInterval: 86400000, // 24æ™‚é–“
    },
    authentication: {
      sessionTimeout: 28800, // 8æ™‚é–“
      mfaRequired: false,
      passwordPolicy: {
        minLength: 8,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSpecialChars: false,
      },
    },
    logging: {
      level: "debug",
      auditEnabled: true,
      retentionDays: 30,
    },
    cors: {
      allowedOrigins: ["http://localhost:3000", "http://localhost:5173"],
      allowCredentials: true,
    },
  },

  production: {
    // æœ¬ç•ªç’°å¢ƒè¨­å®š
    encryption: {
      enabled: true,
      algorithm: "AES-256-GCM",
      keyRotationInterval: 3600000, // 1æ™‚é–“
    },
    authentication: {
      sessionTimeout: 14400, // 4æ™‚é–“
      mfaRequired: true,
      passwordPolicy: {
        minLength: 12,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSpecialChars: true,
        preventReuse: 12,
      },
    },
    logging: {
      level: "info",
      auditEnabled: true,
      retentionDays: 2555, // 7å¹´
    },
    cors: {
      allowedOrigins: ["https://your-domain.com"],
      allowCredentials: true,
    },
    rateLimit: {
      windowMs: 900000, // 15åˆ†
      maxRequests: 100,
      skipSuccessfulRequests: false,
    },
  },
} as const;

/**
 * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã®é©ç”¨
 */
class SecurityConfigManager {
  private config: typeof SECURITY_CONFIGS.production;

  constructor(environment: "development" | "production") {
    this.config = SECURITY_CONFIGS[environment];
  }

  /**
   * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
   * @returns ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼
   */
  getSecurityHeaders(): Record<string, string> {
    return {
      "Strict-Transport-Security":
        "max-age=31536000; includeSubDomains; preload",
      "X-Content-Type-Options": "nosniff",
      "X-Frame-Options": "DENY",
      "X-XSS-Protection": "1; mode=block",
      "Referrer-Policy": "strict-origin-when-cross-origin",
      "Permissions-Policy": "geolocation=(), microphone=(), camera=()",
      "Content-Security-Policy": this.generateCSP(),
    };
  }

  /**
   * CSPãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ç”Ÿæˆ
   * @returns CSPæ–‡å­—åˆ—
   */
  private generateCSP(): string {
    const cspDirectives = [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' https://apis.google.com",
      "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
      "font-src 'self' https://fonts.gstatic.com",
      "img-src 'self' data: https:",
      "connect-src 'self' https://script.google.com https://accounts.google.com",
      "frame-src https://accounts.google.com",
      "object-src 'none'",
      "base-uri 'self'",
      "form-action 'self'",
      "frame-ancestors 'none'",
      "upgrade-insecure-requests",
    ];

    return cspDirectives.join("; ");
  }
}
```

## ã¾ã¨ã‚

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] **èªè¨¼ãƒ»èªå¯**

  - [ ] Google OAuth 2.0ã®å®Ÿè£…
  - [ ] PKCEï¼ˆProof Key for Code Exchangeï¼‰ã®ä½¿ç”¨
  - [ ] å¤šè¦ç´ èªè¨¼ï¼ˆMFAï¼‰ã®å®Ÿè£…
  - [ ] ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®å¼·åŒ–
  - [ ] ãƒ­ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ï¼ˆRBACï¼‰

- [ ] **ãƒ‡ãƒ¼ã‚¿ä¿è­·**

  - [ ] ä¿å­˜æ™‚æš—å·åŒ–ï¼ˆAES-256-GCMï¼‰
  - [ ] è»¢é€æ™‚æš—å·åŒ–ï¼ˆTLS 1.2ä»¥ä¸Šï¼‰
  - [ ] å€‹äººæƒ…å ±ã®ãƒã‚¹ã‚­ãƒ³ã‚°ãƒ»åŒ¿ååŒ–
  - [ ] ãƒ‡ãƒ¼ã‚¿åˆ†é¡ãƒ»ãƒ©ãƒ™ãƒªãƒ³ã‚°
  - [ ] ã‚»ã‚­ãƒ¥ã‚¢ãªã‚­ãƒ¼ç®¡ç†

- [ ] **é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**

  - [ ] HTTPS/TLSã®å¼·åˆ¶
  - [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã®è¨­å®š
  - [ ] Content Security Policyï¼ˆCSPï¼‰
  - [ ] CORSè¨­å®šã®é©åˆ‡ãªåˆ¶é™

- [ ] **å…¥åŠ›æ¤œè¨¼**

  - [ ] å…¥åŠ›å€¤ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
  - [ ] SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
  - [ ] XSSæ”»æ’ƒå¯¾ç­–
  - [ ] CSRFæ”»æ’ƒå¯¾ç­–

- [ ] **ç›£æŸ»ãƒ»ãƒ­ã‚°**

  - [ ] åŒ…æ‹¬çš„ãªç›£æŸ»ãƒ­ã‚°
  - [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆã®ç›£è¦–
  - [ ] ç•°å¸¸æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
  - [ ] ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œãƒ—ãƒ­ã‚»ã‚¹

- [ ] **GDPRãƒ»ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼**

  - [ ] åŒæ„ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
  - [ ] ãƒ‡ãƒ¼ã‚¿ãƒãƒ¼ã‚¿ãƒ“ãƒªãƒ†ã‚£
  - [ ] å¿˜ã‚Œã‚‰ã‚Œã‚‹æ¨©åˆ©
  - [ ] ãƒ‡ãƒ¼ã‚¿ä¿®æ­£æ¨©

- [ ] **å®šæœŸç›£æŸ»**
  - [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã®å®Ÿæ–½
  - [ ] è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³
  - [ ] ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
  - [ ] ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹ãƒã‚§ãƒƒã‚¯

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é€£çµ¡å…ˆ

- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒ¼ãƒ **: security@company.com
- **ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå ±å‘Š**: incident@company.com
- **ç·Šæ€¥é€£çµ¡å…ˆ**: +81-XX-XXXX-XXXX

### é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [APIä»•æ§˜ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](./API_SPECIFICATION.md)
- [ãƒ‡ãƒ¼ã‚¿ç®¡ç†ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](./DATA_MANAGEMENT.md)
- [ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°](./TROUBLESHOOTING.md)
- [ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ãƒ»é‹ç”¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](./SETUP_OPERATIONS.md)
