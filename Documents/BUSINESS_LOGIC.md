# å‹¤æ€ ç®¡ç†ã‚¢ãƒ—ãƒª - ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

## ğŸ¯ æ¦‚è¦

æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ã¯ã€å‹¤æ€ ç®¡ç†ã‚¢ãƒ—ãƒªã®æ ¸ã¨ãªã‚‹ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã«ã¤ã„ã¦è©³ç´°ã«èª¬æ˜ã—ã¾ã™ã€‚ä¸»è¦ãªæ©Ÿèƒ½ã¨ã—ã¦ã€å…¥åŠ›æ¸ˆã¿åˆ¤å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã€å‹¤å‹™æ™‚é–“è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ã€ç·¨é›†å¯èƒ½æœŸé–“åˆ¶é™ã€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«ã€ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯ã€è‡ªå‹•è£œå®Œæ©Ÿèƒ½ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã€é€šçŸ¥ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½ã«ã¤ã„ã¦åŒ…æ‹¬çš„ã«è§£èª¬ã—ã¾ã™ã€‚

## ğŸ“‹ ç›®æ¬¡

1. [å…¥åŠ›æ¸ˆã¿åˆ¤å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ](#å…¥åŠ›æ¸ˆã¿åˆ¤å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ )
2. [å‹¤å‹™æ™‚é–“è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯](#å‹¤å‹™æ™‚é–“è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯)
3. [ç·¨é›†å¯èƒ½æœŸé–“åˆ¶é™](#ç·¨é›†å¯èƒ½æœŸé–“åˆ¶é™)
4. [ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«](#ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«)
5. [ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯](#ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯)
6. [è‡ªå‹•è£œå®Œæ©Ÿèƒ½](#è‡ªå‹•è£œå®Œæ©Ÿèƒ½)
7. [ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°](#ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°)
8. [é€šçŸ¥ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½](#é€šçŸ¥ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½)

## ğŸ“ å…¥åŠ›æ¸ˆã¿åˆ¤å®šã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

### åŸºæœ¬æ¦‚å¿µ

å‹¤æ€ ãƒ‡ãƒ¼ã‚¿ãŒã€Œå…¥åŠ›æ¸ˆã¿ã€ã¨åˆ¤å®šã•ã‚Œã‚‹ãŸã‚ã«ã¯ã€ä»¥ä¸‹ã®å¿…é ˆé …ç›®ãŒã™ã¹ã¦å…¥åŠ›ã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š

1. **å‡ºå‹¤æ™‚é–“** (`startTime`): HH:mmå½¢å¼
2. **é€€å‹¤æ™‚é–“** (`endTime`): HH:mmå½¢å¼
3. **å‹¤å‹™å ´æ‰€** (`location`): æ–‡å­—åˆ—

### ãƒ¬ã‚¬ã‚·ãƒ¼åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯

```typescript
/**
 * å¾“æ¥ã®å…¥åŠ›æ¸ˆã¿åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
 * ã‚·ãƒ³ãƒ—ãƒ«ãªå­˜åœ¨ãƒã‚§ãƒƒã‚¯ã®ã¿å®Ÿè¡Œ
 */
const isDateEntered = (date: Date): boolean => {
  const dateString = formatDate(date); // YYYY-MM-DDå½¢å¼
  const kintaiData = getKintaiDataByDate(dateString);

  return !!(
    kintaiData?.startTime &&
    kintaiData?.endTime &&
    kintaiData?.location
  );
};
```

**ç‰¹å¾´:**

- å˜ç´”ãªå­˜åœ¨ãƒã‚§ãƒƒã‚¯
- ç©ºæ–‡å­—ã‚„ç„¡åŠ¹ãªå€¤ã®æ¤œè¨¼ãªã—
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–

### æ–°åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ï¼ˆEntryStatusManagerï¼‰

```typescript
/**
 * æ–°ã—ã„å…¥åŠ›æ¸ˆã¿åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
 * ã‚ˆã‚Šå³å¯†ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½ã‚’æä¾›
 */
class EntryStatusManager {
  private cache: MonthlyEntryCache | null = null;

  /**
   * æŒ‡å®šæ—¥ã®å…¥åŠ›çŠ¶æ…‹ã‚’åˆ¤å®š
   */
  isDateEntered(date: Date): boolean {
    const dateString = formatDate(date);

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰é«˜é€Ÿå–å¾—
    const cachedResult = this.getCachedStatus(dateString);
    if (cachedResult !== null) {
      return cachedResult;
    }

    // ãƒ‡ãƒ¼ã‚¿å–å¾—ã¨åˆ¤å®š
    const data = this.getKintaiData(dateString);
    const isEntered = this.validateRequiredFields(data);

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ›´æ–°
    this.updateCache(dateString, isEntered);

    return isEntered;
  }

  /**
   * å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å³å¯†ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
   */
  private validateRequiredFields(data: KintaiData | null): boolean {
    if (!data) return false;

    // 1. å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    if (
      !data.startTime?.trim() ||
      !data.endTime?.trim() ||
      !data.location?.trim()
    ) {
      return false;
    }

    // 2. æ™‚é–“å½¢å¼ãƒã‚§ãƒƒã‚¯
    if (
      !this.isValidTimeFormat(data.startTime) ||
      !this.isValidTimeFormat(data.endTime)
    ) {
      return false;
    }

    // 3. æ™‚åˆ»ã®è«–ç†ãƒã‚§ãƒƒã‚¯
    if (!this.isValidTimeSequence(data.startTime, data.endTime)) {
      return false;
    }

    return true;
  }

  /**
   * æ™‚é–“å½¢å¼ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆHH:mmå½¢å¼ï¼‰
   */
  private isValidTimeFormat(timeStr: string): boolean {
    const TIME_PATTERN = /^([0-1]?[0-9]|2[0-3]):([0-5][0-9])$/;
    return TIME_PATTERN.test(timeStr);
  }

  /**
   * æ™‚åˆ»ã®å‰å¾Œé–¢ä¿‚ãƒã‚§ãƒƒã‚¯
   */
  private isValidTimeSequence(startTime: string, endTime: string): boolean {
    const startMinutes = this.timeStringToMinutes(startTime);
    const endMinutes = this.timeStringToMinutes(endTime);

    // æ—¥è·¨ãå‹¤å‹™ã®è€ƒæ…®
    if (endMinutes < startMinutes) {
      // ç¿Œæ—¥ã®å‹¤å‹™ã¨ã—ã¦æ‰±ã†ï¼ˆ24æ™‚é–“ã‚’åŠ ç®—ï¼‰
      return endMinutes + 24 * 60 > startMinutes;
    }

    return endMinutes > startMinutes;
  }
}
```

**ç‰¹å¾´:**

- å³å¯†ãªãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ã‚ˆã‚‹é«˜é€ŸåŒ–
- æ™‚åˆ»ã®è«–ç†ãƒã‚§ãƒƒã‚¯
- æ—¥è·¨ãå‹¤å‹™å¯¾å¿œ

### ä¸¦è¡Œé‹ç”¨ã‚·ã‚¹ãƒ†ãƒ 

ç¾åœ¨ã€æ–°æ—§ä¸¡æ–¹ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’ä¸¦è¡Œé‹ç”¨ã—ã€æ®µéšçš„ã«ç§»è¡Œã‚’é€²ã‚ã¦ã„ã¾ã™ï¼š

```typescript
/**
 * æ–°æ—§ãƒ­ã‚¸ãƒƒã‚¯ã®æ¯”è¼ƒæ©Ÿèƒ½
 */
const compareLogics = (
  date: Date
): {
  legacy: boolean;
  new: boolean;
  match: boolean;
} => {
  const legacy = isDateEntered(date); // ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯
  const newLogic = isDateEnteredNew(date); // æ–°ãƒ­ã‚¸ãƒƒã‚¯

  return {
    legacy,
    new: newLogic,
    match: legacy === newLogic, // çµæœã®ä¸€è‡´æ€§
  };
};
```

**ç§»è¡Œãƒ•ã‚§ãƒ¼ã‚º:**

- **Phase 1**: ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ­ã‚¸ãƒƒã‚¯ã®ã¿ä½¿ç”¨
- **Phase 2**: ä¸¦è¡Œé‹ç”¨ãƒ»æ¯”è¼ƒæ¤œè¨¼ï¼ˆç¾åœ¨ï¼‰
- **Phase 3**: æ–°ãƒ­ã‚¸ãƒƒã‚¯ã¸ã®å®Œå…¨ç§»è¡Œ

## â° å‹¤å‹™æ™‚é–“è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯

### åŸºæœ¬è¨ˆç®—å¼

```typescript
/**
 * å‹¤å‹™æ™‚é–“ã®è‡ªå‹•è¨ˆç®—
 * å‹¤å‹™æ™‚é–“ = é€€å‹¤æ™‚é–“ - å‡ºå‹¤æ™‚é–“ - ä¼‘æ†©æ™‚é–“
 */
const calculateWorkingTime = (
  startTime: string,
  endTime: string,
  breakTime: string = "0:00"
): string => {
  // 1. å…¥åŠ›å€¤ã®æ­£è¦åŒ–
  const normalizedStart = normalizeTimeString(startTime);
  const normalizedEnd = normalizeTimeString(endTime);
  const normalizedBreak = normalizeTimeString(breakTime);

  // 2. åˆ†æ•°ã«å¤‰æ›
  const startMinutes = timeStringToMinutes(normalizedStart);
  const endMinutes = timeStringToMinutes(normalizedEnd);
  const breakMinutes = timeStringToMinutes(normalizedBreak);

  // 3. æ—¥è·¨ãå‹¤å‹™ã®å‡¦ç†
  let workingMinutes: number;
  if (endMinutes < startMinutes) {
    // ç¿Œæ—¥å‹¤å‹™ã®å ´åˆï¼ˆä¾‹: 22:00 ï½ 06:00ï¼‰
    workingMinutes = endMinutes + 24 * 60 - startMinutes;
  } else {
    // åŒæ—¥å‹¤å‹™ã®å ´åˆ
    workingMinutes = endMinutes - startMinutes;
  }

  // 4. ä¼‘æ†©æ™‚é–“ã‚’å·®ã—å¼•ã
  workingMinutes -= breakMinutes;

  // 5. è² ã®å€¤ã®å ´åˆã¯0:00ã‚’è¿”ã™
  if (workingMinutes < 0) {
    return "0:00";
  }

  // 6. HH:mmå½¢å¼ã«å¤‰æ›
  return minutesToTimeString(workingMinutes);
};
```

### æ™‚é–“å½¢å¼ã®çµ±ä¸€å‡¦ç†

#### æ­£è¦åŒ–ãƒ­ã‚¸ãƒƒã‚¯

```typescript
/**
 * æ™‚é–“æ–‡å­—åˆ—ã‚’HH:mmå½¢å¼ã«æ­£è¦åŒ–
 * å…¥åŠ›ä¾‹: "9:30", "09:30", "9:5" â†’ å‡ºåŠ›: "09:30", "09:30", "09:05"
 */
export function normalizeTimeString(timeStr: string): TimeString {
  if (!timeStr || timeStr.trim() === "") {
    return "00:00";
  }

  const trimmed = timeStr.trim();

  // æ—¢ã«æ­£ã—ã„å½¢å¼ã®å ´åˆã¯ãã®ã¾ã¾è¿”ã™
  if (isValidTimeFormat(trimmed)) {
    return trimmed;
  }

  // ã‚³ãƒ­ãƒ³ã§åˆ†å‰²ã—ã¦æ™‚é–“ã¨åˆ†ã‚’å–å¾—
  const parts = trimmed.split(":");
  if (parts.length !== 2) {
    return "00:00";
  }

  const hours = parseInt(parts[0], 10);
  const minutes = parseInt(parts[1], 10);

  // æ•°å€¤ã¨ã—ã¦æœ‰åŠ¹ã§ãªã„å ´åˆã¯00:00ã‚’è¿”ã™
  if (Number.isNaN(hours) || Number.isNaN(minutes)) {
    return "00:00";
  }

  // ç¯„å›²ãƒã‚§ãƒƒã‚¯
  if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
    return "00:00";
  }

  // HH:mmå½¢å¼ã«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
  return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
}
```

#### åˆ†æ•°å¤‰æ›ãƒ­ã‚¸ãƒƒã‚¯

```typescript
/**
 * HH:mmå½¢å¼ã®æ™‚é–“æ–‡å­—åˆ—ã‚’åˆ†æ•°ã«å¤‰æ›
 */
export function timeStringToMinutes(timeStr: TimeString): number {
  if (!isValidTimeFormat(timeStr)) {
    return 0;
  }

  const [hours, minutes] = timeStr.split(":").map((num) => parseInt(num, 10));
  return hours * 60 + minutes;
}

/**
 * åˆ†æ•°ã‚’HH:mmå½¢å¼ã®æ™‚é–“æ–‡å­—åˆ—ã«å¤‰æ›
 */
export function minutesToTimeString(minutes: number): TimeString {
  if (minutes < 0) {
    return "00:00";
  }

  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;

  return `${hours.toString().padStart(2, "0")}:${remainingMinutes.toString().padStart(2, "0")}`;
}
```

### ä¼‘æ†©æ™‚é–“ã®æ‰±ã„

#### ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®š

```typescript
/**
 * ä¼‘æ†©æ™‚é–“ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤å‡¦ç†
 */
const getDefaultBreakTime = (workingMinutes: number): string => {
  // 6æ™‚é–“ä»¥ä¸Šã®å‹¤å‹™ã®å ´åˆã€45åˆ†ã®ä¼‘æ†©ã‚’æ¨å¥¨
  if (workingMinutes >= 6 * 60) {
    return "0:45";
  }

  // 4æ™‚é–“ä»¥ä¸Šã®å‹¤å‹™ã®å ´åˆã€30åˆ†ã®ä¼‘æ†©ã‚’æ¨å¥¨
  if (workingMinutes >= 4 * 60) {
    return "0:30";
  }

  // ãã‚Œä»¥å¤–ã¯ä¼‘æ†©ãªã—
  return "0:00";
};
```

#### æ³•å®šä¼‘æ†©æ™‚é–“ã®ãƒã‚§ãƒƒã‚¯

```typescript
/**
 * åŠ´åƒåŸºæº–æ³•ã«åŸºã¥ãä¼‘æ†©æ™‚é–“ã®ãƒã‚§ãƒƒã‚¯
 */
const validateLegalBreakTime = (
  workingMinutes: number,
  breakMinutes: number
): { isValid: boolean; requiredBreak: number; warning?: string } => {
  // 6æ™‚é–“ä»¥ä¸‹ã®å ´åˆã€ä¼‘æ†©ã¯ä»»æ„
  if (workingMinutes <= 6 * 60) {
    return { isValid: true, requiredBreak: 0 };
  }

  // 6æ™‚é–“è¶…8æ™‚é–“ä»¥ä¸‹ã®å ´åˆã€45åˆ†ä»¥ä¸Šã®ä¼‘æ†©ãŒå¿…è¦
  if (workingMinutes <= 8 * 60) {
    const required = 45;
    return {
      isValid: breakMinutes >= required,
      requiredBreak: required,
      warning:
        breakMinutes < required
          ? `6æ™‚é–“ã‚’è¶…ãˆã‚‹å‹¤å‹™ã«ã¯${required}åˆ†ä»¥ä¸Šã®ä¼‘æ†©ãŒå¿…è¦ã§ã™`
          : undefined,
    };
  }

  // 8æ™‚é–“è¶…ã®å ´åˆã€60åˆ†ä»¥ä¸Šã®ä¼‘æ†©ãŒå¿…è¦
  const required = 60;
  return {
    isValid: breakMinutes >= required,
    requiredBreak: required,
    warning:
      breakMinutes < required
        ? `8æ™‚é–“ã‚’è¶…ãˆã‚‹å‹¤å‹™ã«ã¯${required}åˆ†ä»¥ä¸Šã®ä¼‘æ†©ãŒå¿…è¦ã§ã™`
        : undefined,
  };
};
```

### æ—¥è·¨ãå‹¤å‹™ã®å‡¦ç†

```typescript
/**
 * æ—¥è·¨ãå‹¤å‹™ã®åˆ¤å®šã¨å‡¦ç†
 */
const handleOvernightWork = (
  startTime: string,
  endTime: string
): {
  isOvernight: boolean;
  workingMinutes: number;
  nextDayMinutes: number;
} => {
  const startMinutes = timeStringToMinutes(startTime);
  const endMinutes = timeStringToMinutes(endTime);

  if (endMinutes < startMinutes) {
    // æ—¥è·¨ãå‹¤å‹™
    const totalMinutes = endMinutes + 24 * 60 - startMinutes;
    const nextDayMinutes = endMinutes;

    return {
      isOvernight: true,
      workingMinutes: totalMinutes,
      nextDayMinutes,
    };
  }

  // åŒæ—¥å‹¤å‹™
  return {
    isOvernight: false,
    workingMinutes: endMinutes - startMinutes,
    nextDayMinutes: 0,
  };
};
```

## ğŸ“… ç·¨é›†å¯èƒ½æœŸé–“åˆ¶é™

### åŸºæœ¬è¨­å®š

```typescript
// ç·¨é›†å¯èƒ½æ—¥æ•°ã®è¨­å®šï¼ˆã“ã®å€¤ã‚’å¤‰æ›´ã™ã‚‹ã ã‘ã§å…¨ä½“ã®å‹•ä½œãŒå¤‰ã‚ã‚Šã¾ã™ï¼‰
export const EDITABLE_DAYS = 20;
```

### ç·¨é›†å¯èƒ½æœŸé–“ã®åˆ¤å®š

```typescript
/**
 * æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ãŒç·¨é›†å¯èƒ½æ—¥æ•°ã‚’è¶…ãˆã¦å¤ã„ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
 */
export const isDateTooOld = (date: string): boolean => {
  const targetDate = new Date(date);
  const today = new Date();
  const diffTime = today.getTime() - targetDate.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  return diffDays > EDITABLE_DAYS;
};

/**
 * æ—¥ä»˜ãŒè¨±å®¹ç¯„å›²å†…ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
 * ç¾åœ¨ã‚ˆã‚Šç·¨é›†å¯èƒ½æ—¥æ•°å‰ã‹ã‚‰å½“æ—¥ã¾ã§ãŒæœ‰åŠ¹
 */
export const isDateInValidRange = (date: string): boolean => {
  const targetDate = new Date(date);
  const today = new Date();
  const limitDate = new Date(today);
  limitDate.setDate(today.getDate() - EDITABLE_DAYS);

  return targetDate >= limitDate && targetDate <= today;
};
```

### é¸æŠå¯èƒ½æ—¥ä»˜ã®ç”Ÿæˆ

```typescript
/**
 * ç·¨é›†å¯èƒ½ãªæ—¥ä»˜ã®ãƒªã‚¹ãƒˆã‚’ç”Ÿæˆ
 */
export const getSelectableDates = (): SelectableDate[] => {
  const dates: SelectableDate[] = [];
  const today = new Date();

  // éå»EDITABLE_DAYSæ—¥åˆ†ã‹ã‚‰ä»Šæ—¥ã¾ã§
  for (let i = EDITABLE_DAYS; i >= 0; i--) {
    const date = new Date(today);
    date.setDate(today.getDate() - i);

    const dateString = formatDate(date);
    const displayString = formatDateWithWeekday(dateString);

    dates.push({
      value: dateString,
      label: displayString,
    });
  }

  return dates;
};
```

### UIé€£å‹•ç®‡æ‰€

- `src/utils/dateUtils.ts`: `EDITABLE_DAYS` å®šæ•°ã€`isDateTooOld`ã€`isDateInValidRange`ã€`getSelectableDates` ãŒä¸­å¿ƒçš„ã«åˆ¶å¾¡ã€‚
- `src/components/KintaiForm.tsx`: `isDateTooOld(formState.date)` ã®åˆ¤å®šçµæœã§ä¿å­˜ãƒœã‚¿ãƒ³ã®ã‚¯ãƒ©ã‚¹/æ–‡è¨€ã‚’åˆ‡ã‚Šæ›¿ãˆï¼ˆ20æ—¥è¶…éã§ã€Œç·¨é›†ä¸å¯ã€è¡¨ç¤ºï¼‰ã€‚`getSelectableDates()` ã‚’å–å¾—ã—ã¦æ—¥ä»˜é¸æŠã«ä½¿ç”¨ã€‚
- `src/components/MobileDatePicker.tsx`: ç¾åœ¨ã®å®Ÿè£…ã§ã¯ `selectableDates` ã‚’ç›´æ¥ã¯ä½¿ç”¨ã›ãšã€ä»»æ„ã®æ—¥ä»˜é¸æŠã‚’è¨±å®¹ã€‚ç·¨é›†å¯å¦è‡ªä½“ã¯ `KintaiForm` å´ã§åˆ¶å¾¡ã€‚
- ä»•æ§˜å¤‰æ›´æ–¹æ³•: `src/utils/dateUtils.ts` ã® `EDITABLE_DAYS` ã‚’å¤‰æ›´ã™ã‚Œã°ã€è¨±å®¹æœŸé–“ãŒã‚¢ãƒ—ãƒªå…¨ä½“ã«ä¸€æ‹¬åæ˜ ã•ã‚Œã‚‹ã€‚

### æ¨©é™ç®¡ç†

```typescript
/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç·¨é›†æ¨©é™ã‚’ãƒã‚§ãƒƒã‚¯
 */
const checkEditPermission = (
  date: string,
  userId: string
): {
  canEdit: boolean;
  reason?: string;
} => {
  // 1. æ—¥ä»˜ã®ç·¨é›†å¯èƒ½æœŸé–“ãƒã‚§ãƒƒã‚¯
  if (isDateTooOld(date)) {
    return {
      canEdit: false,
      reason: `ç·¨é›†å¯èƒ½æœŸé–“ã‚’è¶…ãˆã¦ã„ã¾ã™ï¼ˆ${EDITABLE_DAYS}æ—¥ä»¥å†…ã®ã¿ç·¨é›†å¯èƒ½ï¼‰`,
    };
  }

  // 2. æœªæ¥æ—¥ã®ãƒã‚§ãƒƒã‚¯
  const targetDate = new Date(date);
  const today = new Date();
  if (targetDate > today) {
    return {
      canEdit: false,
      reason: "æœªæ¥ã®æ—¥ä»˜ã¯ç·¨é›†ã§ãã¾ã›ã‚“",
    };
  }

  // 3. ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ãƒã‚§ãƒƒã‚¯ï¼ˆå°†æ¥ã®æ‹¡å¼µç”¨ï¼‰
  // const userRole = getUserRole(userId);
  // if (userRole === 'readonly') {
  //   return { canEdit: false, reason: "èª­ã¿å–ã‚Šå°‚ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã™" };
  // }

  return { canEdit: true };
};
```

## ğŸ” ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ«

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

```typescript
/**
 * å‹¤æ€ ãƒ‡ãƒ¼ã‚¿ã®åŒ…æ‹¬çš„ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
 */
const validateKintaiData = (data: KintaiData): ValidationErrors => {
  const errors: ValidationErrors = {};

  // 1. æ—¥ä»˜ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  if (!data.date) {
    errors.date = "æ—¥ä»˜ã¯å¿…é ˆã§ã™";
  } else if (isDateTooOld(data.date)) {
    errors.date = `ç·¨é›†å¯èƒ½æœŸé–“ã‚’è¶…ãˆã¦ã„ã¾ã™ï¼ˆ${EDITABLE_DAYS}æ—¥ä»¥å†…ã®ã¿ç·¨é›†å¯èƒ½ï¼‰`;
  }

  // 2. å‡ºå‹¤æ™‚é–“ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  if (!data.startTime?.trim()) {
    errors.startTime = "å‡ºå‹¤æ™‚é–“ã¯å¿…é ˆã§ã™";
  } else if (!isValidTimeFormat(data.startTime)) {
    errors.startTime = "æ­£ã—ã„æ™‚é–“å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆHH:mmï¼‰";
  }

  // 3. é€€å‹¤æ™‚é–“ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  if (!data.endTime?.trim()) {
    errors.endTime = "é€€å‹¤æ™‚é–“ã¯å¿…é ˆã§ã™";
  } else if (!isValidTimeFormat(data.endTime)) {
    errors.endTime = "æ­£ã—ã„æ™‚é–“å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆHH:mmï¼‰";
  }

  // 4. å‹¤å‹™å ´æ‰€ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
  if (!data.location?.trim()) {
    errors.general = "å‹¤å‹™å ´æ‰€ã¯å¿…é ˆã§ã™";
  }

  // 5. æ™‚åˆ»ã®å‰å¾Œé–¢ä¿‚ãƒã‚§ãƒƒã‚¯
  if (
    data.startTime &&
    data.endTime &&
    isValidTimeFormat(data.startTime) &&
    isValidTimeFormat(data.endTime)
  ) {
    if (!isTimeBeforeOrEqual(data.startTime, data.endTime)) {
      // æ—¥è·¨ãã§ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼
      const startMinutes = timeStringToMinutes(data.startTime);
      const endMinutes = timeStringToMinutes(data.endTime);

      if (endMinutes <= startMinutes) {
        errors.endTime = "é€€å‹¤æ™‚é–“ã¯å‡ºå‹¤æ™‚é–“ã‚ˆã‚Šå¾Œã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™";
      }
    }
  }

  // 6. ä¼‘æ†©æ™‚é–“ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆä»»æ„é …ç›®ï¼‰
  if (data.breakTime && !isValidTimeFormat(data.breakTime)) {
    errors.general = "ä¼‘æ†©æ™‚é–“ã¯æ­£ã—ã„æ™‚é–“å½¢å¼ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆHH:mmï¼‰";
  }

  // 7. å‹¤å‹™æ™‚é–“ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
  if (data.startTime && data.endTime && data.breakTime) {
    const workingTime = calculateWorkingTime(
      data.startTime,
      data.endTime,
      data.breakTime
    );

    const workingMinutes = timeStringToMinutes(workingTime);

    // 24æ™‚é–“ã‚’è¶…ãˆã‚‹å‹¤å‹™ã®ãƒã‚§ãƒƒã‚¯
    if (workingMinutes > 24 * 60) {
      errors.general = "å‹¤å‹™æ™‚é–“ãŒ24æ™‚é–“ã‚’è¶…ãˆã¦ã„ã¾ã™";
    }

    // æ³•å®šä¼‘æ†©æ™‚é–“ã®ãƒã‚§ãƒƒã‚¯
    const breakMinutes = timeStringToMinutes(data.breakTime);
    const breakValidation = validateLegalBreakTime(
      workingMinutes,
      breakMinutes
    );

    if (!breakValidation.isValid && breakValidation.warning) {
      errors.general = breakValidation.warning;
    }
  }

  return errors;
};
```

### ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

```typescript
/**
 * Google Apps Scriptå´ã§ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
 */
function validateKintaiDataOnServer(data) {
  const errors = [];

  // 1. é‡è¤‡ãƒã‚§ãƒƒã‚¯
  const existingData = getKintaiDataByDate(data.userId, data.date);
  if (existingData && existingData.id !== data.id) {
    errors.push("ã“ã®æ—¥ä»˜ã®ãƒ‡ãƒ¼ã‚¿ã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™");
  }

  // 2. ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ãƒã‚§ãƒƒã‚¯
  const user = getUserById(data.userId);
  if (!user || user.status !== "active") {
    errors.push("ç„¡åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã™");
  }

  // 3. ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
  if (data.startTime && data.endTime) {
    const workingMinutes = calculateWorkingMinutes(
      data.startTime,
      data.endTime,
      data.breakTime || "0:00"
    );

    if (workingMinutes < 0) {
      errors.push("å‹¤å‹™æ™‚é–“ãŒè² ã®å€¤ã«ãªã£ã¦ã„ã¾ã™");
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}
```

## ğŸ”„ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

### ã‚¨ãƒ©ãƒ¼åˆ†é¡

```typescript
enum ErrorType {
  VALIDATION_ERROR = "validation_error",
  NETWORK_ERROR = "network_error",
  PERMISSION_ERROR = "permission_error",
  DATA_CONFLICT = "data_conflict",
  SYSTEM_ERROR = "system_error",
}

interface BusinessLogicError {
  type: ErrorType;
  message: string;
  field?: string;
  code?: string;
  details?: any;
}
```

### ã‚¨ãƒ©ãƒ¼å‡¦ç†æˆ¦ç•¥

```typescript
/**
 * ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ã®çµ±ä¸€å‡¦ç†
 */
const handleBusinessLogicError = (
  error: BusinessLogicError
): {
  shouldRetry: boolean;
  userMessage: string;
  logLevel: "info" | "warn" | "error";
} => {
  switch (error.type) {
    case ErrorType.VALIDATION_ERROR:
      return {
        shouldRetry: false,
        userMessage: error.message,
        logLevel: "info",
      };

    case ErrorType.NETWORK_ERROR:
      return {
        shouldRetry: true,
        userMessage:
          "ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾Œã«å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚",
        logLevel: "warn",
      };

    case ErrorType.PERMISSION_ERROR:
      return {
        shouldRetry: false,
        userMessage: "ã“ã®æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚",
        logLevel: "warn",
      };

    case ErrorType.DATA_CONFLICT:
      return {
        shouldRetry: false,
        userMessage:
          "ãƒ‡ãƒ¼ã‚¿ã®ç«¶åˆãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚",
        logLevel: "error",
      };

    default:
      return {
        shouldRetry: false,
        userMessage:
          "ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚",
        logLevel: "error",
      };
  }
};
```

## ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

```typescript
/**
 * è¨ˆç®—çµæœã®ãƒ¡ãƒ¢åŒ–
 */
const memoizedCalculateWorkingTime = (() => {
  const cache = new Map<string, string>();

  return (
    startTime: string,
    endTime: string,
    breakTime: string = "0:00"
  ): string => {
    const key = `${startTime}-${endTime}-${breakTime}`;

    if (cache.has(key)) {
      return cache.get(key)!;
    }

    const result = calculateWorkingTime(startTime, endTime, breakTime);
    cache.set(key, result);

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™ï¼ˆ1000ã‚¨ãƒ³ãƒˆãƒªï¼‰
    if (cache.size > 1000) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }

    return result;
  };
})();
```

### ãƒãƒƒãƒå‡¦ç†

```typescript
/**
 * æœˆé–“ãƒ‡ãƒ¼ã‚¿ã®ä¸€æ‹¬å‡¦ç†
 */
const processBatchValidation = async (
  monthlyData: KintaiData[]
): Promise<Map<string, ValidationErrors>> => {
  const results = new Map<string, ValidationErrors>();

  // ä¸¦åˆ—å‡¦ç†ã§ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
  const validationPromises = monthlyData.map(async (data) => {
    const errors = await validateKintaiData(data);
    return { date: data.date, errors };
  });

  const validationResults = await Promise.all(validationPromises);

  validationResults.forEach(({ date, errors }) => {
    if (Object.keys(errors).length > 0) {
      results.set(date, errors);
    }
  });

  return results;
};
```

---

**æœ€çµ‚æ›´æ–°**: 2025-01-27  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0.0  
**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**:

- [ã‚·ã‚¹ãƒ†ãƒ æ¦‚è¦](./SYSTEM_OVERVIEW.md)
- [ãƒ‡ãƒ¼ã‚¿ç®¡ç†](./DATA_MANAGEMENT.md)
- [APIä»•æ§˜](./API_SPECIFICATION.md)
